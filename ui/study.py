# study_generation.py

import time
from automation.create_study import create_study_for_user
import streamlit as st
import json
import streamlit.components.v1 as components
from datetime import datetime
from openai import OpenAI
from config import aii  # Your OpenAI API key module

class StudyGenerationProcess:
    def __init__(self, auth, currentProduct):
        self.auth = auth
        self.currentProduct = currentProduct

    def run(self):
        if "study_step" not in st.session_state:
            st.session_state.study_step = 10
        if "study_data" not in st.session_state or not st.session_state.study_data:
            st.session_state.study_data = {
                "study_name": "",
                "study_description": "",
                "questions": [],
                "prelim_questions": [],
                "final_thoughts":"",
                "respondent_orientation":""
            }

        if "study_autogenerated" not in st.session_state:
            st.session_state.study_autogenerated = False
        # üîÅ Only auto-generate if on step 1 AND hasn't been done yet
        if st.session_state.study_step == 0:
            with st.spinner("Thinking deeply about your product..."):
                self._auto_generate_full_study_product()
            st.session_state.study_step = 4
            st.session_state.study_autogenerated = True
            st.rerun()
        product_data = self.currentProduct
      
        if st.session_state.study_step == 1:
            self._step1_setup(product_data)
        elif st.session_state.study_step == 2:
            self._step2_questions(product_data)
        elif st.session_state.study_step == 3:
            self._step3_prelim_questions()
        elif st.session_state.study_step == 4:
            self._step4_review()

    def _auto_generate_full_study_product(self):
        product = self.currentProduct
        if not product:
            st.error("No product data found.")
            return
        st.markdown("## üìë Study Generation ")
        with st.status("Generating study...", expanded=True) as status:
            status.update(label="üß† Generating Study Description...")
            desc_prompt = (
                f"Create a comprehensive study description for a product called {product['product_name']}. "
                f"Product details: {product['technical_explanation']} "
                f"Consumer pitch: {product['consumer_pitch']} "
                # Team Inputted Prompt
                f""
                "Make this into a 4‚Äì5 paragraph response."
            )
            description = self._call_gpt(desc_prompt, max_tokens=400, json_mode=False)

            status.update(label="üß™ Generating  Respondent Orientation...")
            respondent_orientation_prompt = (
                f"Write a short, friendly orientation message for a research study about the product '{product['product_name']}'.\n\n"
                f"Product overview:\n{product['consumer_pitch']}\n\n"
                f"Technical background:\n{product['technical_explanation']}\n\n"
                "This message should introduce the participant to the study, explain the purpose in simple terms, "
                "and encourage them to answer honestly and thoughtfully. Keep the tone warm, human, and concise (no more than 2 short paragraphs). "
                "Avoid technical jargon, and focus on making the participant feel comfortable and informed."
            )
            respondent_orientation = self._call_gpt(respondent_orientation_prompt, max_tokens=250, json_mode=False)

            status.update(label="üß™ Generating Main Questions...")
            q_prompt = (
                f"Product name: {product['product_name']}"
                f"Product details: {product['technical_explanation']} "
                f"Product description: {description} "
                # Team Inputted Questions Prompt
                f"""
                We are interested in understanding the factors that make a person want to adopt or comply with a product, experience, or solution. These factors may include physical needs, emotional desires, lifestyle improvements, or other personal motivations.
                You are working with the following:
                Product name
                Product description
                Product details
                For this product or concept, create four questions that are relevant to the benefit or experience being offered. For each question, provide four answers in simple English. These answers should be short descriptive statements that reflect what the person using this product would say they "want" or "think is important."
                To summarize:
                You know the product or concept based on the study name and description provided above.


                You are to ask four relevant questions about the person's everyday life, needs, or hopes. These questions must each begin with the phrase:
                "Describe a situation that is important to you personally..."


                Before generating the question, make sure that the object of the question is radically different for each question. compare each question to each other and make sure they are radically different

                i.e "Describe a situtation that is important you personally...(this part should be radically different from the other questions)"
                
                Each question should have four answers. These answers should reflect:


                What the person experiences in daily life,


                Or what they care about related to the product‚Äôs purpose,


                Or what they are hoping for over the next few years.


                Keep all language simple, natural, and consumer-friendly.

    

"""
                "Return a valid JSON object in this format:\n"
                "{ \"questions\": [ { \"question\": \"\", \"options\": [\"\", \"\", \"\", \"\"] } ] }"
            )
            questions_json = self._call_gpt(q_prompt, max_tokens=700, json_mode=True)

            status.update(label="üìã Generating Prelim Questions...")
            p_prompt = (
                f"Product name: {product['product_name']}"
                f"Product details: {product['technical_explanation']} "
                f"Product description: {description} "
                f"Study questions: {questions_json}" 


                # Team Inputted Preliminary Prompt
                f"""
                Read the study questions and all 16 answers. Based on the 16 answers, generate 8 radically different questions that directly ask the user about themselves. Each question must paint a vivid picture of who the user is‚Äîwhat they feel about the product, how they see themselves, and how the product makes them feel. Each question should be written in the second person and ask the user a question.

For each question, provide exactly 3 radically different answers . Each answer should be a full sentence with 5-10 words. The answers must be rich with information and should reveal how the user thinks, their rituals, emotions, habits, or worldview in relation to the situation. The answers MUST NOT BE in second person.

Next, return to the description of the product. Create 8 questions that directly ask the user about their experience with the product and what it reveals about their life (e.g., if the product is a health product, ask how it fits into their health rituals or mindset).

Now, imagine you‚Äôre looking at this product and asking:
‚ÄúWhat does this product reveal about you?‚Äù
Write 8 classification questions that each directly ask the user to identify something about themselves‚Äîhow they think, act, or feel‚Äîthrough the lens of the product.

Each of the 8 questions should include 3 mutually exclusive and unexpected answers that:

    The first answer is phrased with strong love

    The second answer is phrased with indifference

    The third answer is phrased with strong hate

    The answers should be directly relevant to the question, and be realistic and socially acceptable

    The answers are written as full sentences (max 10 words)

    The answers are rich in meaning and emotionally vivid

    The answers are something distinct and usable for segmentation

    The answers are not in second person
    

All questions must speak directly to the user and every answer must help us understand who they are on a deeper level. Avoid generic phrasing‚Äîthese should feel personal, human, and revealing.




"""
                "Return a valid JSON object which has only questions key which holds the list of all the questions and their answers (no other keys or other data ) in this format:\n"
                "{ \"questions\": [ { \"question\": \"\", \"options\": [\"\", \"\", \"\"] } ] }"
            )
            prelim_json = self._call_gpt(p_prompt, max_tokens=2000, json_mode=True)
            # print({"main questions ": questions_json})
            # print({"perlim questions ": prelim_json})

            status.update(label="üìã Generating Final Thoughts...")
            final_thoughts_prompt = (
                f"Write a closing statement for a research study about the product '{product['product_name']}'.\n\n"
                f"Product description:\n{description}\n\n"
                f"The participant has just completed questions about their needs, lifestyle, mindset, and relationship to the product.\n\n"
                "Write 2‚Äì3 short paragraphs that:\n"
                "- Thank the participant genuinely for their time and insights\n"
                "- Reinforce why their responses matter to improving the product and understanding its users\n"
                "- Reflect the product‚Äôs tone (warm, human, innovative, or insightful)\n"
                "- Feel personal and intentional, not robotic or generic\n"
                "- End with a line that leaves the participant feeling valued and understood\n"
            )
            final_thoughts = self._call_gpt(final_thoughts_prompt, max_tokens=300, json_mode=False)

            try:
                main_questions = json.loads(questions_json)["questions"]
                prelim_questions = json.loads(prelim_json)["questions"]
            except Exception as e:
                st.error("‚ùå Failed to parse AI response.")
                return

            st.session_state.study_data = {
                "study_name": product["product_name"],
                "study_description": description,
                "questions": main_questions,
                "prelim_questions": prelim_questions,
                "respondent_orientation":respondent_orientation,
                "final_thoughts":final_thoughts

            }

            status.update(label="‚úÖ Study generated successfully!", state="complete")

    def _step1_setup(self, product):
        study_data = st.session_state.study_data
        default_name = product["product_name"] if product else ""
        study_name = st.text_input("Study Name", value=default_name or study_data["study_name"])

        col1, col2 = st.columns([3, 1])
        with col1:
            st.text_area("Study Description", value=study_data["study_description"], height=200)
        with col2:
            st.write("")
            st.write("")
            if st.button("‚ú® Generate Description", help="Generate using AI"):
                if product:
                    prompt = f"Create a comprehensive study description for a product called {product['product_name']}. "
                    prompt += f"Product details: {product['technical_explanation']} "
                    prompt += f"Consumer pitch: {product['consumer_pitch']}"
                    prompt += "Make this into a paragraph form and make it of 4-5 paragraphs."
                    generated_desc = self._call_gpt(prompt, max_tokens=300)
                    if generated_desc:
                        st.session_state.study_data["study_description"] = generated_desc
                        st.rerun()

        col1, col2 = st.columns([1, 1])
        with col1:
            if st.button("Cancel"):
                st.session_state.study_step = 0
                st.session_state.study_data = None
                st.rerun()
        with col2:
            if st.button("Next: Generate Questions ‚Üí"):
                st.session_state.study_data.update({
                    "study_name": study_name,
                    "study_description": st.session_state.study_data["study_description"]
                })
                st.session_state.study_step = 2
                st.rerun()

    def _step2_questions(self, product):
        study_data = st.session_state.study_data
        st.info(f"Generating questions for: {study_data['study_name']}")

        for i, q in enumerate(study_data["questions"]):
            with st.expander(f"Question #{i+1}: {q['question']}", expanded=False):
                col1, col2 = st.columns([4, 1])
                with col1:
                    question = st.text_input(f"Edit Question {i+1}", value=q["question"], key=f"q_{i}")
                with col2:
                    if st.button("‚ùå Delete", key=f"del_q_{i}"):
                        study_data["questions"].pop(i)
                        st.rerun()
                options = q["options"]
                for j in range(4):
                    options[j] = st.text_input(f"Option {j+1}", value=options[j], key=f"q_{i}_opt_{j}")

        col1, col2 = st.columns([1, 1])
        # with col1:
        #     if st.button("‚Üê Back"):
        #         st.session_state.study_step = 1
        #         st.rerun()
        with col2:
            if st.button("Next: Prelim Questions ‚Üí"):
                st.session_state.study_step = 3
                st.rerun()

    def _step3_prelim_questions(self):
        study_data = st.session_state.study_data
        prelim_questions = study_data["prelim_questions"]
        st.info("Add preliminary questions (e.g., demographic questions)")

        for i, q in enumerate(prelim_questions):
            with st.expander(f"Prelim #{i+1}: {q['question']}", expanded=False):
                col1, col2 = st.columns([4, 1])
                with col1:
                    question = st.text_input(f"Prelim Question {i+1}", value=q["question"], key=f"prelim_q_{i}")
                with col2:
                    if st.button("‚ùå", key=f"del_prelim_{i}"):
                        prelim_questions.pop(i)
                        st.rerun()
                options = q["options"]
                for j in range(3):
                    options[j] = st.text_input(f"Option {j+1}", value=options[j], key=f"prelim_{i}_opt_{j}")

        col1, col2, col3 = st.columns([1, 1, 1])
        with col1:
            if st.button("‚Üê Back to Questions"):
                st.session_state.study_step = 2
                st.rerun()
        with col3:
            if st.button("Review Study ‚Üí"):
                st.session_state.study_step = 4
                st.rerun()

    def _step4_review(self):
        study_data = st.session_state.study_data
        st.subheader("üîç Study Review")
        st.markdown(f"**Study Name:** {study_data['study_name']}")
        st.markdown(f"**Description:** {study_data['study_description']}")
        st.markdown(f"**Respondent Orientation:** {study_data['respondent_orientation']}")
        st.markdown(f"**Final Thoughts  :** {study_data['final_thoughts']}")

        st.subheader("Study Questions (4x4)")
        for i, q in enumerate(study_data["questions"]):
            with st.expander(f"Question #{i+1}: {q['question']}", expanded=False):
                # st.markdown(f"{i+1}. {q['question']}")
                for j, opt in enumerate(q["options"]):
                    st.markdown(f"    {chr(65+j)}. {opt}")

        st.subheader("Classification Questions")
        for i, q in enumerate(study_data["prelim_questions"]):
            with st.expander(f"Prelim #{i+1}: {q['question'].replace(f"{i+1}", "").replace(".","")}", expanded=False):
                # st.markdown(f"{i+1}. {q['question']}")
                for j, opt in enumerate(q["options"]):
                    st.markdown(f"    {chr(65+j)}. {opt}")

        if st.button("üíæ Create study report"):
            project_id = st.session_state.current_project["_id"]
            user = st.session_state.current_user
            username = user.get("email", "unknown_user@example.com")
            password = user.get("password", "no_password")

            final_format = {
            "username": username,
            "password": password,
            "study_name": study_data['study_name'],
            "question_1": study_data['questions'][0]['question'],
            "question_1_answers": study_data['questions'][0]['options'],
            "question_2": study_data['questions'][1]['question'],
            "question_2_answers": study_data['questions'][1]['options'],
            "question_3": study_data['questions'][2]['question'],
            "question_3_answers": study_data['questions'][2]['options'],
            "question_4": study_data['questions'][3]['question'],
            "question_4_answers": study_data['questions'][3]['options'],
            }

            # Add classification questions
            for i in range(8):
                q = study_data['prelim_questions'][i]
                final_format[f"classification_question_{i+1}"] = q['question']
                final_format[f"classification_question_{i+1}_answers"] = q['options']

            # Add rest
            final_format.update({
                "respondent_orientation": study_data['respondent_orientation'],
                "rating_scale_question": "Please rate the following according to the scale below:",
                "rating_1": "Strongly Disagree",
                "rating_2": "Disagree",
                "rating_3": "Neutral",
                "rating_4": "Agree",
                "rating_5": "Strongly Agree",
                "final_thoughts": study_data['final_thoughts'],
                "keyword": "invention",
                "respondents": "100"
            })

            

            progress_bar = st.progress(0)
            status_text = st.empty()
            log_container = st.empty()
            log_content = ""
            
                    # Custom log function with reverse order and auto-scroll
            def log_function(message):
                nonlocal log_content
                # Add timestamp and prepend new message
                timestamp = time.strftime("%H:%M:%S")
                log_content = f"[{timestamp}] {message}\n" + log_content
                
                # Update the text area
                log_container.text_area("Progress Log", value=log_content, height=300)
                
                # JavaScript to scroll to the bottom
                # scroll_script = """
                # <script>
                # function scrollToBottom() {
                #     var textAreas = parent.document.querySelectorAll('.stTextArea textarea');
                #     if (textAreas.length > 0) {
                #         textAreas[textAreas.length - 1].scrollTop = textAreas[textAreas.length - 1].scrollHeight;
                #     }
                # }
                # scrollToBottom();
                # </script>
                # """
                # components.html(scroll_script, height=0)
            
            # Run study creation
            success = create_study_for_user(
                data=final_format,
                progress_bar=progress_bar,
                status_text=status_text,
                log_function=log_function
            )
            
            # Handle result
            if success:
                # Clear session data
                if 'study_data' in st.session_state:
                    del st.session_state['study_data']
                
                # Show success message
                st.success("‚úÖ Study created successfully! Check your email.")
                
                # Clear progress elements after delay
                time.sleep(3)
                progress_bar.empty()
                status_text.empty()
                log_container.empty()
            else:
                status_text.error("‚ùå Study creation failed")
                st.error("Please check the progress log for details")       






            # success = self.auth.save_study(project_id, study_data)
            # if success:
            #     st.success("Study saved successfully!")
            #     st.session_state.study_step = 0
            #     st.session_state.study_data = None
            # else:
            #     st.error("Failed to save study")

        if st.button("‚Üê Edit Questions"):
            st.session_state.study_step = 3
            st.rerun()

    def _call_gpt(self, prompt, max_tokens=500, json_mode=False):
        try:
            client = OpenAI(api_key=aii)
            response = client.chat.completions.create(
                model="gpt-4.1-nano",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=3000,
                response_format={"type": "json_object"} if json_mode else None
            )
            print(response.choices[0].message.content)
            return response.choices[0].message.content
        except Exception as e:
            st.error(f"AI generation failed: {str(e)}")
            return None