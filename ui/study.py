# study_generation.py

import streamlit as st
import json
from datetime import datetime
from openai import OpenAI
from config import aii  # Your OpenAI API key module

class StudyGenerationProcess:
    def __init__(self, auth, currentProduct):
        self.auth = auth
        self.currentProduct = currentProduct

    def run(self):
        if "study_step" not in st.session_state:
            st.session_state.study_step = 10
        if "study_data" not in st.session_state or not st.session_state.study_data:
            st.session_state.study_data = {
                "study_name": "",
                "study_description": "",
                "questions": [],
                "prelim_questions": []
            }

        if "study_autogenerated" not in st.session_state:
            st.session_state.study_autogenerated = False
        # üîÅ Only auto-generate if on step 1 AND hasn't been done yet
        if st.session_state.study_step == 0:
            with st.spinner("Thinking deeply about your product..."):
                self._auto_generate_full_study()
            st.session_state.study_step = 4
            st.session_state.study_autogenerated = True
            st.rerun()
        product_data = self.currentProduct
      
        if st.session_state.study_step == 1:
            self._step1_setup(product_data)
        elif st.session_state.study_step == 2:
            self._step2_questions(product_data)
        elif st.session_state.study_step == 3:
            self._step3_prelim_questions()
        elif st.session_state.study_step == 4:
            self._step4_review()

    def _auto_generate_full_study(self):
        product = self.currentProduct
        if not product:
            st.error("No product data found.")
            return
        st.markdown("## üìë Study Generation ")
        with st.status("Generating study...", expanded=True) as status:
            status.update(label="üß† Generating Study Description...")
            desc_prompt = (
                f"Create a comprehensive study description for a product called {product['product_name']}. "
                f"Product details: {product['technical_explanation']} "
                f"Consumer pitch: {product['consumer_pitch']} "
                # Team Inputted Prompt
                f""
                "Make this into a 4‚Äì5 paragraph response."
            )
            description = self._call_gpt(desc_prompt, max_tokens=400, json_mode=False)

            status.update(label="üß™ Generating Main Questions...")
            q_prompt = (
                f"Product name: {product['product_name']}"
                f"Product details: {product['technical_explanation']} "
                f"Product description: {description} "
                # Team Inputted Questions Prompt
                f"""
                We are interested in understanding the factors that make a person want to adopt or comply with a product, experience, or solution. These factors may include physical needs, emotional desires, lifestyle improvements, or other personal motivations.
                You are working with the following:
                Product name
                Product description
                Product details
                For this product or concept, create four questions that are relevant to the benefit or experience being offered. For each question, provide four answers in simple English. These answers should be short descriptive statements that reflect what the person using this product would say they "want" or "think is important."
                To summarize:
                You know the product or concept based on the study name and description provided above.


                You are to ask four relevant questions about the person's everyday life, needs, or hopes. These questions must each begin with the phrase:
                "Describe a situation that is important to you personally..."


                Before generating the question, make sure that the object of the question is radically different for each question. compare each question to each other and make sure they are radically different

                i.e "Describe a situtation that is important you personally...(this part should be radically different from the other questions)"
                
                Each question should have four answers. These answers should reflect:


                What the person experiences in daily life,


                Or what they care about related to the product‚Äôs purpose,


                Or what they are hoping for over the next few years.


                Keep all language simple, natural, and consumer-friendly.

    

"""
                "Return a valid JSON object in this format:\n"
                "{ \"questions\": [ { \"question\": \"\", \"options\": [\"\", \"\", \"\", \"\"] } ] }"
            )
            questions_json = self._call_gpt(q_prompt, max_tokens=700, json_mode=True)

            status.update(label="üìã Generating Prelim Questions...")
            p_prompt = (
                f"Product name: {product['product_name']}"
                f"Product details: {product['technical_explanation']} "
                f"Product description: {description} "
                f"Study questions: {questions_json}" 


                # Team Inputted Preliminary Prompt
                f"""
                Read the study questions and all 16 answers. Based on the 16 answers, generate 18 radically different questions that directly ask the user about themselves. Each question must paint a vivid picture of who the user is‚Äîwhat they feel about the product, how they see themselves, and how the product makes them feel. Each question should be written in the second person and ask the user a question.

For each question, provide exactly 3 radically different answers. Each answer should be a full sentence with 5-10 words. The answers must be rich with information and should reveal how the user thinks, their rituals, emotions, habits, or worldview in relation to the situation. The answers MUST NOT BE in second person.

Next, return to the description of the product. Create 18 questions that directly ask the user about their experience with the product and what it reveals about their life (e.g., if the product is a health product, ask how it fits into their health rituals or mindset).

Now, imagine you‚Äôre looking at this product and asking:
‚ÄúWhat does this product reveal about you?‚Äù
Write 18 classification questions that each directly ask the user to identify something about themselves‚Äîhow they think, act, or feel‚Äîthrough the lens of the product.

Each of the 18 questions should include 3 mutually exclusive and unexpected answers that:

    The answers are written as full sentences (max 10 words)

    The answers are rich in meaning and emotionally vivid

    The answers are something distinct and usable for segmentation

    The answers are not in second person

   

All questions must speak directly to the user and every answer must help us understand who they are on a deeper level. Avoid generic phrasing‚Äîthese should feel personal, human, and revealing.




"""
                "Return a valid JSON object in this format:\n"
                "{ \"questions\": [ { \"question\": \"\", \"options\": [\"\", \"\", \"\"] } ] }"
            )
            prelim_json = self._call_gpt(p_prompt, max_tokens=2000, json_mode=True)

            try:
                main_questions = json.loads(questions_json)["questions"]
                prelim_questions = json.loads(prelim_json)["questions"]
            except Exception as e:
                st.error("‚ùå Failed to parse AI response.")
                return

            st.session_state.study_data = {
                "study_name": product["product_name"],
                "study_description": description,
                "questions": main_questions,
                "prelim_questions": prelim_questions
            }

            status.update(label="‚úÖ Study generated successfully!", state="complete")

    def _step1_setup(self, product):
        study_data = st.session_state.study_data
        default_name = product["product_name"] if product else ""
        study_name = st.text_input("Study Name", value=default_name or study_data["study_name"])

        col1, col2 = st.columns([3, 1])
        with col1:
            st.text_area("Study Description", value=study_data["study_description"], height=200)
        with col2:
            st.write("")
            st.write("")
            if st.button("‚ú® Generate Description", help="Generate using AI"):
                if product:
                    prompt = f"Create a comprehensive study description for a product called {product['product_name']}. "
                    prompt += f"Product details: {product['technical_explanation']} "
                    prompt += f"Consumer pitch: {product['consumer_pitch']}"
                    prompt += "Make this into a paragraph form and make it of 4-5 paragraphs."
                    generated_desc = self._call_gpt(prompt, max_tokens=300)
                    if generated_desc:
                        st.session_state.study_data["study_description"] = generated_desc
                        st.rerun()

        col1, col2 = st.columns([1, 1])
        with col1:
            if st.button("Cancel"):
                st.session_state.study_step = 0
                st.session_state.study_data = None
                st.rerun()
        with col2:
            if st.button("Next: Generate Questions ‚Üí"):
                st.session_state.study_data.update({
                    "study_name": study_name,
                    "study_description": st.session_state.study_data["study_description"]
                })
                st.session_state.study_step = 2
                st.rerun()

    def _step2_questions(self, product):
        study_data = st.session_state.study_data
        st.info(f"Generating questions for: {study_data['study_name']}")

        for i, q in enumerate(study_data["questions"]):
            with st.expander(f"Question #{i+1}: {q['question']}", expanded=False):
                col1, col2 = st.columns([4, 1])
                with col1:
                    question = st.text_input(f"Edit Question {i+1}", value=q["question"], key=f"q_{i}")
                with col2:
                    if st.button("‚ùå Delete", key=f"del_q_{i}"):
                        study_data["questions"].pop(i)
                        st.rerun()
                options = q["options"]
                for j in range(4):
                    options[j] = st.text_input(f"Option {j+1}", value=options[j], key=f"q_{i}_opt_{j}")

        col1, col2 = st.columns([1, 1])
        with col1:
            if st.button("‚Üê Back"):
                st.session_state.study_step = 1
                st.rerun()
        with col2:
            if st.button("Next: Prelim Questions ‚Üí"):
                st.session_state.study_step = 3
                st.rerun()

    def _step3_prelim_questions(self):
        study_data = st.session_state.study_data
        prelim_questions = study_data["prelim_questions"]
        st.info("Add preliminary questions (e.g., demographic questions)")

        for i, q in enumerate(prelim_questions):
            with st.expander(f"Prelim #{i+1}: {q['question']}", expanded=False):
                col1, col2 = st.columns([4, 1])
                with col1:
                    question = st.text_input(f"Prelim Question {i+1}", value=q["question"], key=f"prelim_q_{i}")
                with col2:
                    if st.button("‚ùå", key=f"del_prelim_{i}"):
                        prelim_questions.pop(i)
                        st.rerun()
                options = q["options"]
                for j in range(3):
                    options[j] = st.text_input(f"Option {j+1}", value=options[j], key=f"prelim_{i}_opt_{j}")

        col1, col2, col3 = st.columns([1, 1, 1])
        with col1:
            if st.button("‚Üê Back to Questions"):
                st.session_state.study_step = 2
                st.rerun()
        with col3:
            if st.button("Review Study ‚Üí"):
                st.session_state.study_step = 4
                st.rerun()

    def _step4_review(self):
        study_data = st.session_state.study_data
        st.subheader("üîç Study Review")
        st.markdown(f"**Study Name:** {study_data['study_name']}")
        st.markdown(f"**Description:** {study_data['study_description']}")

        st.subheader("Study Questions")
        for i, q in enumerate(study_data["questions"]):
            with st.expander(f"Question #{i+1}: {q['question']}", expanded=False):
                # st.markdown(f"{i+1}. {q['question']}")
                for j, opt in enumerate(q["options"]):
                    st.markdown(f"    {chr(65+j)}. {opt}")

        st.subheader("Preliminary Questions")
        for i, q in enumerate(study_data["prelim_questions"]):
            with st.expander(f"Prelim #{i+1}: {q['question'].replace(f"{i+1}", "").replace(".","")}", expanded=False):
                # st.markdown(f"{i+1}. {q['question']}")
                for j, opt in enumerate(q["options"]):
                    st.markdown(f"    {chr(65+j)}. {opt}")

        # if st.button("üíæ Save Study"):
        #     project_id = st.session_state.current_project["_id"]
        #     success = self.auth.save_study(project_id, study_data)
        #     if success:
        #         st.success("Study saved successfully!")
        #         st.session_state.study_step = 0
        #         st.session_state.study_data = None
        #     else:
        #         st.error("Failed to save study")

        if st.button("‚Üê Edit Questions"):
            st.session_state.study_step = 3
            st.rerun()

    def _call_gpt(self, prompt, max_tokens=500, json_mode=False):
        try:
            client = OpenAI(api_key=aii)
            response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=max_tokens,
                response_format={"type": "json_object"} if json_mode else None
            )
            return response.choices[0].message.content
        except Exception as e:
            st.error(f"AI generation failed: {str(e)}")
            return None